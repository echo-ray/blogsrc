---
title: arp介绍
date: 2018-07-30 12:12:28
tags:
- net
---

### 1. 介绍

arp完成IP和mac的映射关系，三层的IP是无法直接和而成的mac通讯的

需要用arp来获取目标mac来通讯

广域网就是一个一个的局域网组合成的
<!-- more -->
### 2. 局域网的通讯过程

1 A要给B发送数据包，首先在A的本地arp缓存中寻找B所对应的mac

2 a找到了就直接把b的mac填入目标mac位置，进行发送

3 a找不到就在本机启动arp

4 a会在本机的一块网卡上面向本机所在的局域网广播发送ARP请求分组，内容为：我的(a)的IP是192.186.0.2，我的mac是#########，问下，IP是192.168.0.33的住的的mac地址是啥

5 该局域网内的所有主机都会收到a的arp请求分组

6 主机b收到以后，看到a的arp请求中的IP地址在b的本机上面，就会单独(单播)向a发送arp响应，并在响应中写入自己的mac地址，内容为：我的IP地址为192.168.0.2，我的mac地址是#######，其余的主机都会丢弃a发送的arp请求

7 a收到b的响应以后就会在a的arp缓存中添加b的ip与mac映射关系

把b当成路由器就会进行向外网发送

b会将数据包通过查找下一跳的路由mac地址，一次类推

局域网内由新加入的机器或者由IP改动主机，该主机都会向局域网内的其他主机广播自己的IP，如果其他主机本来就有新加入主机的IP就会响应上面的广播警告，新加入的主机收集到该警告后就会触发本机的IP冲突警告机制


### 3. 抓包分析

客户端
eth0 00:0c:29:d2:c7:aa 192.168.18.129

服务端
eth0 00:0c:29:b3:a2:54 192.168.18.10
eth3 00:0c:29:b3:a2:68 192.168.18.11
eth4 00:0c:29:b3:a2:5e 192.168.18.12

客户端->服务端

192.168.18.129 ping --> 192.168.18.10

服务端抓包
```bash
#收到客户端ARP请求
00:0c:29:d2:c7:aa > ff:ff:ff:ff:ff:ff, ARP, length 60: arp who-has 192.168.18.10 tell 192.168.18.129
#服务端的三张网卡均响应，其中5e的eth4首先响应
00:0c:29:b3:a2:5e > 00:0c:29:d2:c7:aa, ARP, length 60: arp reply 192.168.18.10 is-at 00:0c:29:b3:a2:5e
00:0c:29:b3:a2:54 > 00:0c:29:d2:c7:aa, ARP, length 60: arp reply 192.168.18.10 is-at 00:0c:29:b3:a2:54
00:0c:29:b3:a2:68 > 00:0c:29:d2:c7:aa, ARP, length 60: arp reply 192.168.18.10 is-at 00:0c:29:b3:a2:68
#客户端会对首先响应的网卡接口发送icmp包
00:0c:29:d2:c7:aa > 00:0c:29:b3:a2:5e, IPv4, length 98: 192.168.18.129 > 192.168.18.10: ICMP echo request, id 32313, seq 1, length 64
#服务端会让ping目标IP所在的网卡接口去发送响应icmp数据包
00:0c:29:b3:a2:54 > 00:0c:29:d2:c7:aa, IPv4, length 98: 192.168.18.10 > 192.168.18.129: ICMP echo reply, id 32313, seq 1, length 64
#服务端向客户端广播ARP找客户端
00:0c:29:b3:a2:54 > 00:0c:29:d2:c7:aa, ARP, length 60: arp who-has 192.168.18.129 tell 192.168.18.10
#客户端响应服务端ARP请求
00:0c:29:d2:c7:aa > 00:0c:29:b3:a2:54, ARP, length 60: arp reply 192.168.18.129 is-at 00:0c:29:d2:c7:aa
```
上面看到主机ARP请求中包含的IP在自己的主机上，主机上的网卡都会做出回应，不管ARP请求中的IP是否在该网卡上面。
如何配置只让ARP请求中的IP所在的网卡回应呢？

情况一：主机上的网卡上的IP分别在不通的网段

```bash
sysctl -w net.ipv4.conf.all.arp_filter=1
```

情况二：主机上的网卡上的ip在同一个网段

```bash
#只有ARP请求中的IP在本接口上才做出响应
sysctl -w net.ipv4.conf.all.arp_ignore=1
#主机发送数据包的时候需要知道目的mac，在通过ARP寻找目的mac的时候
#在主机上的众多网卡中应该选择哪个网卡的IP作为arp的请求的源IP
#
sysctl -w net.ipv4.conf.all.arp_announce=2
```
