---
title: 正则表达式介绍
date: 2019-4-17 12:14:28
tags:
- tools
---

这里对正则表达式做一个简单的介绍

<!--more-->

# 元字符

元字符是正则表达式里面的语言，通过不同的元字符来匹配不同的文本

```
.	匹配除换行符以外的任意字符 这里是字符 比如 l. 就回匹配任意存在l的地方，然后后面跟一个非换行符的字符， 也就是说会匹配两个字符
\w	匹配字母或数字或下划线或汉字 
\s	匹配任意的空白符
\d	匹配数字
\b	匹配单词的开始或结束
^	匹配字符串的开始
$	匹配字符串的结束
```

# 重复

对元字符匹配后的字符的重复限定，也就是说重复符号在元字符或者分组之后，表示匹配结果的重复情况

```
*	    重复零次或更多次 0 d* 字符d重复0次或者多次
+	    重复一次或更多次 1
?	    重复零次或一次 0 1
{n}	    重复n次
{n,}	重复n次或更多次
{n,m}	重复n到m次
```
# 集合匹配

匹配给定集合中的一个元素，使用 [] 中括号把给定的集合包起来

下面的例子是匹配集合 aenos 中的一个

```
[aenos]
```

# 分歧

通过 | 来进行对匹配进行分组

```
3|2 匹配字符2或者3
```

# 反义

通过 ^ 和 [] 表示

```bash
[^:] 所有的非冒号的字符
```

# 分组

对元字符匹配后的结果进行分组，分组使用小括号 ()

```bash
((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
```

也可以不分配分组的组名

```bash
(?:exp) exp过滤的分组没有组名
```

下面解释这个匹配IP地址的表达式，我们知道常见的IP地址每个段都不会超过255

```bash
((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
```

我们写出IP地址的格式  111.111.111.111

首先匹配第一段

```
(2[0-4]\d|25[0-5]|[01]?\d\d?)

2[0-4]\d  2 匹配2 [0-4] 匹配0到4之间的数字 \d 匹配以为数字
25 [0-5]  25 匹配25两个数字 [0-5] 匹配0到5之间的数字
[01]? \d \d?  [01]?匹配0或者1开头  \d 数字0-9(\d代表数字0-9)匹配一次 \d? 数字匹配0次活1次

\. 的意思是将 . 进行转义

((2[0-4]\d|25[0-5]|[01]?\d\d?)\.) 这个就是匹配IP地址第一段加 . 

{3} 就是将上面匹配的重复三次

(2[0-4]\d|25[0-5]|[01]?\d\d?) 和之前一样就是匹配0-255的数字
```

